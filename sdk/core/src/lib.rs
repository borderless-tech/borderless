pub mod collections;
pub mod contracts;
pub mod lazy;
pub mod log;

pub use anyhow::{anyhow as new_error, ensure, Context, Error, Result};

pub mod serialize {
    pub use serde_json::from_slice;
    pub use serde_json::from_value;
    pub use serde_json::to_value;
    pub use serde_json::Error;
    pub use serde_json::Value;
}

// Directly export macros, so that the user can write:
// #[borderless::contract], #[borderless::agent] and #[borderless::action]
pub use borderless_sdk_macros::{action, contract, State};

/// This module is **not** part of the public API.
/// It exists, because the procedural macros and some internal implementations (like the contract runtime) rely on it.
///
/// You probably don't want to use this directly.
#[doc(hidden)]
#[path = "private.rs"]
pub mod __private;

// Re-export all id-types at top-level
pub use borderless_id_types::*;

// Re-export entire hash crate
pub use borderless_hash as hash;

// Re-export some parts of the http module
pub mod http;

pub mod prelude {
    pub use crate::contracts::*;
    pub use crate::events::*;
}

pub mod events {
    use borderless_id_types::{AgentId, ContractId};
    use serde::{Deserialize, Serialize};
    use serde_json::Value;
    use std::str::FromStr;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(untagged)]
    pub enum MethodOrId {
        ByName { method: String },
        ById { method_id: u32 }, // < TODO Use first bit for blinding here, to distinguish user and system actions ?
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct CallAction {
        #[serde(flatten)]
        pub method: MethodOrId,
        pub params: Value,
    }

    impl FromStr for CallAction {
        type Err = serde_json::Error;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            serde_json::from_str(s)
        }
    }

    impl CallAction {
        pub fn by_method(method_name: impl AsRef<str>, params: Value) -> Self {
            Self {
                method: MethodOrId::ByName {
                    method: method_name.as_ref().to_string(),
                },
                params,
            }
        }

        pub fn by_method_id(method_id: u32, params: Value) -> Self {
            Self {
                method: MethodOrId::ById { method_id },
                params,
            }
        }

        pub fn method_name(&self) -> Option<&str> {
            match &self.method {
                MethodOrId::ByName { method } => Some(method.as_str()),
                MethodOrId::ById { .. } => None,
            }
        }

        pub fn method_id(&self) -> Option<u32> {
            match self.method {
                MethodOrId::ByName { .. } => None,
                MethodOrId::ById { method_id } => Some(method_id),
            }
        }

        pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
            serde_json::from_slice(bytes)
        }

        pub fn pretty_print(&self) -> Result<String, serde_json::Error> {
            serde_json::to_string_pretty(&self)
        }

        pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
            serde_json::to_vec(&self)
        }
    }

    /// An outgoing event for another contract
    #[derive(Debug)]
    pub struct ContractCall {
        pub contract_id: ContractId,
        pub action: CallAction,
    }

    pub struct ProcessCall {
        pub agent_id: AgentId,
        pub action: CallAction,
    }

    /// Output Events generated by a contract or sw-agent
    pub struct Events {
        pub contracts: Vec<ContractCall>,
        pub local: Vec<ProcessCall>,
    }
}
