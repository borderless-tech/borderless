pub mod collections;
pub mod contracts;
pub mod lazy;
pub mod log;

pub use anyhow::{anyhow as new_error, ensure, Context, Error, Result};

pub mod serialize {
    pub use serde_json::from_slice;
    pub use serde_json::from_value;
    pub use serde_json::to_value;
    pub use serde_json::Error;
    pub use serde_json::Value;
}

// Directly export macros, so that the user can write:
// #[borderless::contract], #[borderless::agent] and #[borderless::action]
pub use borderless_sdk_macros::{action, contract, NamedSink, State};

/// This module is **not** part of the public API.
/// It exists, because the procedural macros and some internal implementations (like the contract runtime) rely on it.
///
/// You probably don't want to use this directly.
#[doc(hidden)]
#[path = "private.rs"]
pub mod __private;

// Re-export all id-types at top-level
pub use borderless_id_types::*;

// Re-export entire hash crate
pub use borderless_hash as hash;

// Re-export some parts of the http module
pub mod http;

pub mod prelude {
    pub use crate::contracts::*;
    pub use crate::events::*;
}

/// Trait that must be implemented on the `Sink` enum inside a contract module.
///
/// Implementing this trait ensures, that you can split the sink into a static string
/// (which represents the 'alias'-string we use to match sinks) and a CallAction object,
/// which will be used to generate the output transaction.
pub trait NamedSink {
    /// Splits the sink into its alias and the encoded CallAction object.
    ///
    /// Errors while converting the action should be converted into a wasm trap.
    fn into_action(self) -> (&'static str, events::CallAction);
}

pub mod events {
    use borderless_id_types::{AgentId, BorderlessId, ContractId};
    use serde::{Deserialize, Serialize};
    use serde_json::Value;
    use std::{fmt::Display, str::FromStr};

    use crate::NamedSink;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(untagged)]
    pub enum MethodOrId {
        ByName { method: String },
        ById { method_id: u32 }, // < TODO Use first bit for blinding here, to distinguish user and system actions ?
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct CallAction {
        #[serde(flatten)]
        pub method: MethodOrId,
        pub params: Value,
    }

    impl FromStr for CallAction {
        type Err = serde_json::Error;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            serde_json::from_str(s)
        }
    }

    impl CallAction {
        pub fn by_method(method_name: impl AsRef<str>, params: Value) -> Self {
            Self {
                method: MethodOrId::ByName {
                    method: method_name.as_ref().to_string(),
                },
                params,
            }
        }

        pub fn by_method_id(method_id: u32, params: Value) -> Self {
            Self {
                method: MethodOrId::ById { method_id },
                params,
            }
        }

        pub fn method_name(&self) -> Option<&str> {
            match &self.method {
                MethodOrId::ByName { method } => Some(method.as_str()),
                MethodOrId::ById { .. } => None,
            }
        }

        pub fn method_id(&self) -> Option<u32> {
            match self.method {
                MethodOrId::ByName { .. } => None,
                MethodOrId::ById { method_id } => Some(method_id),
            }
        }

        pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
            serde_json::from_slice(bytes)
        }

        pub fn pretty_print(&self) -> Result<String, serde_json::Error> {
            serde_json::to_string_pretty(&self)
        }

        pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
            serde_json::to_vec(&self)
        }
    }

    // /// Represents a target that should execute some action.
    // ///
    // /// Since contracts and software-agents both use the [`CallAction`] struct,
    // /// but also use different ID types, this enum can be used in cases where a `CallAction`
    // /// is bundled with either a [`ContractId`] or [`AgentId`].
    // pub enum TargetId {
    //     Agent(AgentId),
    //     Contract(ContractId),
    // }

    /// An outgoing event for another contract
    #[derive(Debug, Serialize, Deserialize)]
    pub struct ContractCall {
        pub contract_id: ContractId,
        pub action: CallAction,
    }

    #[derive(Debug, Serialize, Deserialize)]
    pub struct ProcessCall {
        pub agent_id: AgentId,
        pub action: CallAction,
    }

    /// Output Events generated by a contract or sw-agent
    #[derive(Debug, Serialize, Deserialize)]
    pub struct Events {
        pub contracts: Vec<ContractCall>,
        pub local: Vec<ProcessCall>,
    }

    /// Specifies the Sink-Type of an `ActionOutput`.
    ///
    /// A sink can be either a named sink, that gets referenced by its `sink_alias`.
    /// The real contract- or process-id is taken from the Contract- or ProcessInfo,
    /// using [`ContractInfo::find_sink`] (or [`ProcessInfo::find_sink`]).
    ///
    /// In general it is recommended to use the named sink-type, as it provides the most
    /// comfort and fool-proof way of interacting with other contracts or processes.
    ///
    /// However, for maximum flexibility, users can also refer to a sink directly by their
    /// [`ContractId`] or [`ProcessId`].
    #[derive(Debug)]
    pub enum SinkType {
        Named(String),
        Agent(AgentId),
        Contract(ContractId),
    }

    impl Display for SinkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                SinkType::Named(s) => write!(f, "{s}"),
                SinkType::Agent(s) => write!(f, "{s}"),
                SinkType::Contract(s) => write!(f, "{s}"),
            }
        }
    }

    /// Output events of a contract's action
    #[derive(Default)]
    pub struct ActionOutput {
        actions: Vec<(SinkType, CallAction)>,
    }

    impl ActionOutput {
        pub fn new() -> Self {
            Self::default()
        }

        pub fn add_event<T: NamedSink>(&mut self, target: T) {
            let (sink_name, action) = target.into_action();
            self.actions
                .push((SinkType::Named(sink_name.to_string()), action));
        }

        /// Adds a generic event to the output - with dynamic dispatch of the output sinks.
        ///
        /// In contrast to [`ActionOutput::add_event`] the event type must only implement `TryInto<CallAction>`,
        /// since the user directly tells us towards which sink the event should be send.
        /// This is only necessary, if the `Sink` has been added after the contract was instantiated.
        pub fn add_event_dynamic<S, IntoAction>(&mut self, sink_alias: S, action: IntoAction)
        where
            S: AsRef<str>,
            IntoAction: TryInto<CallAction>,
            <IntoAction as TryInto<CallAction>>::Error: std::fmt::Display,
        {
            let alias = sink_alias.as_ref().to_string();
            let action = match action.try_into() {
                Ok(a) => a,
                Err(e) => {
                    crate::error!(
                        "critical error while converting action for dynamic sink '{alias}': {e}"
                    );
                    crate::__private::abort();
                }
            };
            self.actions.push((SinkType::Named(alias), action))
        }

        pub fn add_event_for_contract<IntoAction>(
            &mut self,
            contract_id: ContractId,
            action: IntoAction,
        ) where
            IntoAction: TryInto<CallAction>,
            <IntoAction as TryInto<CallAction>>::Error: std::fmt::Display,
        {
            let action = match action.try_into() {
                Ok(a) => a,
                Err(e) => {
                    crate::error!(
                        "critical error while converting action for dynamic sink '{contract_id}': {e}"
                    );
                    crate::__private::abort();
                }
            };
            self.actions
                .push((SinkType::Contract(contract_id.into()), action.into()))
        }

        pub fn add_event_for_process<IntoAction>(&mut self, agent_id: AgentId, action: IntoAction)
        where
            IntoAction: Into<CallAction>,
            <IntoAction as TryInto<CallAction>>::Error: std::fmt::Display,
        {
            let action = match action.try_into() {
                Ok(a) => a,
                Err(e) => {
                    crate::error!(
                        "critical error while converting action for dynamic sink '{agent_id}': {e}"
                    );
                    crate::__private::abort();
                }
            };
            self.actions.push((SinkType::Agent(agent_id), action))
        }
    }

    /// An event Sink for either a contract or sw-agent
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum Sink {
        Contract {
            contract_id: ContractId,
            alias: String,
            restrict_to_users: Vec<BorderlessId>,
        },
        Agent {
            agent_id: AgentId,
            alias: String,
            owner: BorderlessId,
        },
    }

    impl Sink {
        /// Creates a new Sink for a software-agent
        pub fn agent(agent_id: AgentId, alias: String, owner: BorderlessId) -> Sink {
            Sink::Agent {
                agent_id,
                alias: alias.to_ascii_uppercase(),
                owner,
            }
        }

        /// Creates a new Sink for a SmartContract
        pub fn contract(
            contract_id: ContractId,
            alias: String,
            restrict_to_users: Vec<BorderlessId>,
        ) -> Sink {
            Sink::Contract {
                contract_id,
                alias: alias.to_ascii_uppercase(),
                restrict_to_users,
            }
        }

        /// Consumes the sink and returns the same sink,
        /// but with alias converted to ascii-uppercase.
        pub fn ensure_uppercase_alias(self) -> Self {
            match self {
                Sink::Contract {
                    contract_id,
                    alias,
                    restrict_to_users,
                } => Sink::Contract {
                    contract_id,
                    alias: alias.to_ascii_uppercase(),
                    restrict_to_users,
                },
                Sink::Agent {
                    agent_id,
                    alias,
                    owner,
                } => Sink::Agent {
                    agent_id,
                    alias: alias.to_ascii_uppercase(),
                    owner,
                },
            }
        }

        /// Checks weather or not the given user has access to this sink
        pub fn has_access(&self, user: BorderlessId) -> bool {
            match self {
                Sink::Agent { owner, .. } => *owner == user,
                Sink::Contract {
                    restrict_to_users, ..
                } => {
                    // If the vector is empty, everyone has access
                    restrict_to_users.is_empty() || restrict_to_users.iter().any(|u| *u == user)
                }
            }
        }

        pub fn alias(&self) -> String {
            match self {
                Sink::Agent { alias, .. } => alias.to_ascii_uppercase(),
                Sink::Contract { alias, .. } => alias.to_ascii_uppercase(),
            }
        }

        pub fn is_process(&self) -> bool {
            match self {
                Sink::Agent { .. } => true,
                Sink::Contract { .. } => false,
            }
        }
    }
}
