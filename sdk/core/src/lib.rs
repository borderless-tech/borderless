pub mod agents;
pub mod collections;
pub mod contracts;
pub mod lazy;
pub mod log;

pub use anyhow::{anyhow as new_error, ensure, Context, Error, Result};

pub mod serialize {
    pub use serde_json::from_slice;
    pub use serde_json::from_value;
    pub use serde_json::to_value;
    pub use serde_json::Error;
    pub use serde_json::Value;
}

// Directly export macros, so that the user can write:
// #[borderless::contract], #[borderless::agent] and #[borderless::action]
pub use borderless_sdk_macros::{action, contract, NamedSink, State};

/// This module is **not** part of the public API.
/// It exists, because the procedural macros and some internal implementations (like the contract runtime) rely on it.
///
/// You probably don't want to use this directly.
#[doc(hidden)]
#[path = "private.rs"]
pub mod __private;

// Re-export all id-types at top-level
pub use borderless_id_types::*;

// Re-export entire hash crate
pub use borderless_hash as hash;

// Re-export some parts of the http module
pub mod http;

pub mod prelude {
    pub use crate::contracts::*;
    pub use crate::events::*;
}

/// Trait that must be implemented on the `Sink` enum inside a contract module.
///
/// Implementing this trait ensures, that you can split the sink into a static string
/// (which represents the 'alias'-string we use to match sinks) and a CallAction object,
/// which will be used to generate the output transaction.
pub trait NamedSink {
    /// Splits the sink into its alias and the encoded CallAction object.
    ///
    /// Errors while converting the action should be converted into a wasm trap.
    fn into_action(self) -> (&'static str, events::CallAction);
}

pub mod events {
    use anyhow::anyhow;
    use borderless_id_types::{AgentId, BorderlessId, ContractId};
    use serde::{Deserialize, Serialize};
    use serde_json::Value;
    use std::{fmt::Display, str::FromStr};

    use crate::{debug, error, NamedSink};

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(untagged)]
    pub enum MethodOrId {
        ByName { method: String },
        ById { method_id: u32 }, // < TODO Use first bit for blinding here, to distinguish user and system actions ?
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct CallAction {
        #[serde(flatten)]
        pub method: MethodOrId,
        pub params: Value,
    }

    impl FromStr for CallAction {
        type Err = serde_json::Error;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            serde_json::from_str(s)
        }
    }

    impl CallAction {
        pub fn new(method: MethodOrId, params: Value) -> Self {
            Self { method, params }
        }

        pub fn by_method(method_name: impl AsRef<str>, params: Value) -> Self {
            Self {
                method: MethodOrId::ByName {
                    method: method_name.as_ref().to_string(),
                },
                params,
            }
        }

        pub fn by_method_id(method_id: u32, params: Value) -> Self {
            Self {
                method: MethodOrId::ById { method_id },
                params,
            }
        }

        pub fn method_name(&self) -> Option<&str> {
            match &self.method {
                MethodOrId::ByName { method } => Some(method.as_str()),
                MethodOrId::ById { .. } => None,
            }
        }

        pub fn method_id(&self) -> Option<u32> {
            match self.method {
                MethodOrId::ByName { .. } => None,
                MethodOrId::ById { method_id } => Some(method_id),
            }
        }

        pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
            serde_json::from_slice(bytes)
        }

        pub fn pretty_print(&self) -> Result<String, serde_json::Error> {
            serde_json::to_string_pretty(&self)
        }

        pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
            serde_json::to_vec(&self)
        }
    }

    // /// Represents a target that should execute some action.
    // ///
    // /// Since contracts and software-agents both use the [`CallAction`] struct,
    // /// but also use different ID types, this enum can be used in cases where a `CallAction`
    // /// is bundled with either a [`ContractId`] or [`AgentId`].
    // pub enum TargetId {
    //     Agent(AgentId),
    //     Contract(ContractId),
    // }

    /// An outgoing event for another contract
    #[derive(Debug, Serialize, Deserialize)]
    pub struct ContractCall {
        pub contract_id: ContractId,
        pub action: CallAction,
    }

    #[derive(Debug, Serialize, Deserialize)]
    pub struct ProcessCall {
        pub agent_id: AgentId,
        pub action: CallAction,
    }

    /// Output Events generated by a contract or sw-agent
    #[derive(Debug, Default, Serialize, Deserialize)]
    pub struct Events {
        pub contracts: Vec<ContractCall>,
        pub local: Vec<ProcessCall>,
    }

    impl Events {
        /// Returns `true` if there are no events at all
        pub fn is_empty(&self) -> bool {
            self.contracts.is_empty() && self.local.is_empty()
        }

        /// Decodes the `Events` with [`postcard`]
        pub fn from_bytes(bytes: &[u8]) -> Result<Self, postcard::Error> {
            // TODO: Postcard or json ?
            postcard::from_bytes(bytes)
        }

        /// Encodes the `Events` with [`postcard`]
        pub fn to_bytes(&self) -> Result<Vec<u8>, postcard::Error> {
            // TODO: Postcard or json ?
            postcard::to_allocvec(self)
        }
    }

    /// Specifies the Sink-Type of an `ActionOutput`.
    ///
    /// A sink can be either a named sink, that gets referenced by its `sink_alias`.
    /// The real contract- or process-id is taken from the Contract- or ProcessInfo,
    /// using [`ContractInfo::find_sink`] (or [`ProcessInfo::find_sink`]).
    ///
    /// In general it is recommended to use the named sink-type, as it provides the most
    /// comfort and fool-proof way of interacting with other contracts or processes.
    ///
    /// However, for maximum flexibility, users can also refer to a sink directly by their
    /// [`ContractId`] or [`ProcessId`].
    #[derive(Debug)]
    pub enum SinkType {
        Named(String),
        Agent(AgentId),
        Contract(ContractId),
    }

    impl Display for SinkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                SinkType::Named(s) => write!(f, "{s}"),
                SinkType::Agent(s) => write!(f, "{s}"),
                SinkType::Contract(s) => write!(f, "{s}"),
            }
        }
    }

    /// Output events of a contract's action
    #[derive(Default)]
    pub struct ActionOutput {
        actions: Vec<(SinkType, CallAction)>,
    }

    impl ActionOutput {
        pub fn new() -> Self {
            Self::default()
        }

        pub fn add_event<T: NamedSink>(&mut self, target: T) {
            let (sink_name, action) = target.into_action();
            self.actions
                .push((SinkType::Named(sink_name.to_string()), action));
        }

        /// Adds a generic event to the output - with dynamic dispatch of the output sinks.
        ///
        /// In contrast to [`ActionOutput::add_event`] the event type must only implement `TryInto<CallAction>`,
        /// since the user directly tells us towards which sink the event should be send.
        /// This is only necessary, if the `Sink` has been added after the contract was instantiated.
        pub fn add_event_dynamic<S, IntoAction>(&mut self, sink_alias: S, action: IntoAction)
        where
            S: AsRef<str>,
            IntoAction: TryInto<CallAction>,
            <IntoAction as TryInto<CallAction>>::Error: std::fmt::Display,
        {
            let alias = sink_alias.as_ref().to_string();
            let action = match action.try_into() {
                Ok(a) => a,
                Err(e) => {
                    error!(
                        "critical error while converting action for dynamic sink '{alias}': {e}"
                    );
                    crate::__private::abort();
                }
            };
            self.actions.push((SinkType::Named(alias), action))
        }

        pub fn add_event_for_contract<IntoAction>(
            &mut self,
            contract_id: ContractId,
            action: IntoAction,
        ) where
            IntoAction: TryInto<CallAction>,
            <IntoAction as TryInto<CallAction>>::Error: std::fmt::Display,
        {
            let action = match action.try_into() {
                Ok(a) => a,
                Err(e) => {
                    error!(
                        "critical error while converting action for dynamic sink '{contract_id}': {e}"
                    );
                    crate::__private::abort();
                }
            };
            self.actions.push((SinkType::Contract(contract_id), action))
        }

        pub fn add_event_for_process<IntoAction>(&mut self, agent_id: AgentId, action: IntoAction)
        where
            IntoAction: TryInto<CallAction>,
            <IntoAction as TryInto<CallAction>>::Error: std::fmt::Display,
        {
            let action = match action.try_into() {
                Ok(a) => a,
                Err(e) => {
                    error!(
                        "critical error while converting action for dynamic sink '{agent_id}': {e}"
                    );
                    crate::__private::abort();
                }
            };
            self.actions.push((SinkType::Agent(agent_id), action))
        }
    }

    /// Trait that indicates that a return type can be used as an output of an action function.
    ///
    /// Note: This trait converts `()`, `ActionOutput`, `Result<(), E>` and `Result<ActionOutput, E>` into [`Events`].
    /// The implementation of `ActionOutput` also checks, if the writer actually has access to a sink.
    pub trait ActionOutEvent: private::Sealed {
        fn convert_out_events(self) -> crate::Result<Events>;
    }

    mod private {
        pub trait Sealed {}
    }

    impl private::Sealed for () {}
    impl ActionOutEvent for () {
        fn convert_out_events(self) -> crate::Result<Events> {
            Ok(Events::default())
        }
    }

    impl private::Sealed for ActionOutput {}
    impl ActionOutEvent for ActionOutput {
        fn convert_out_events(self) -> crate::Result<Events> {
            let caller = crate::contracts::env::executor();
            let sinks = crate::contracts::env::sinks();

            let mut contracts = Vec::new();
            let mut local = Vec::new();

            // TODO: There is an edge-case here; we currently have no solution,
            // if multiple participants in a contract have access to the same sink !
            //
            // Idea: Find these places and do a pseudo-random (but deterministic) choice.
            // Or we could solve this from the outside; somehow..
            for (sink, action) in self.actions {
                match sink {
                    SinkType::Named(alias) => {
                        if let Some(sink) = sinks.iter().find(|s| s.has_alias(&alias)) {
                            if !sink.has_access(caller) {
                                debug!("caller {caller} does not have access to sink {alias}");
                                continue;
                            }
                            match sink {
                                Sink::Contract { contract_id, .. } => {
                                    // TODO
                                    contracts.push(ContractCall {
                                        contract_id: *contract_id,
                                        action,
                                    })
                                }
                                Sink::Agent { agent_id, .. } => local.push(ProcessCall {
                                    agent_id: *agent_id,
                                    action,
                                }),
                            }
                        } else {
                            // TODO: Should this be an error or should we just log the error here ?
                            return Err(anyhow!("Failed to find sink '{alias}', which is referenced in the action output"));
                        }
                    }
                    SinkType::Agent(agent_id) => local.push(ProcessCall { agent_id, action }),
                    // TODO: The edge-case also applies here I guess ??
                    SinkType::Contract(contract_id) => contracts.push(ContractCall {
                        contract_id,
                        action,
                    }),
                }
            }
            Ok(Events { contracts, local })
        }
    }

    impl<E> private::Sealed for Result<ActionOutput, E> where
        E: std::error::Error + Send + Sync + 'static
    {
    }
    impl<E> ActionOutEvent for Result<ActionOutput, E>
    where
        E: std::error::Error + Send + Sync + 'static,
    {
        fn convert_out_events(self) -> crate::Result<Events> {
            let inner = self?;
            inner.convert_out_events()
        }
    }

    /// An event Sink for either a contract or sw-agent
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum Sink {
        Contract {
            contract_id: ContractId,
            alias: String,
            restrict_to_users: Vec<BorderlessId>,
        },
        Agent {
            agent_id: AgentId,
            alias: String,
            owner: BorderlessId,
        },
    }

    impl Sink {
        /// Creates a new Sink for a software-agent
        pub fn agent(agent_id: AgentId, alias: String, owner: BorderlessId) -> Sink {
            Sink::Agent {
                agent_id,
                alias: alias.to_ascii_uppercase(),
                owner,
            }
        }

        /// Creates a new Sink for a SmartContract
        pub fn contract(
            contract_id: ContractId,
            alias: String,
            restrict_to_users: Vec<BorderlessId>,
        ) -> Sink {
            Sink::Contract {
                contract_id,
                alias: alias.to_ascii_uppercase(),
                restrict_to_users,
            }
        }

        /// Checks weather or not the given user has access to this sink
        pub fn has_access(&self, user: BorderlessId) -> bool {
            match self {
                Sink::Agent { owner, .. } => *owner == user,
                Sink::Contract {
                    restrict_to_users, ..
                } => {
                    // If the vector is empty, everyone has access
                    restrict_to_users.is_empty() || restrict_to_users.iter().any(|u| *u == user)
                }
            }
        }

        pub fn has_alias(&self, alias: impl AsRef<str>) -> bool {
            let own_alias = match self {
                Sink::Agent { alias, .. } | Sink::Contract { alias, .. } => alias,
            };
            alias.as_ref().eq_ignore_ascii_case(own_alias)
        }

        pub fn is_process(&self) -> bool {
            match self {
                Sink::Agent { .. } => true,
                Sink::Contract { .. } => false,
            }
        }
    }
}

pub mod time {
    use borderless_abi as abi;

    use std::{
        ops::{Add, AddAssign, Sub, SubAssign},
        time::Duration,
    };

    // Very simple re-implementation of the SystemTime API
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct SystemTime(i64);

    pub fn timestamp() -> i64 {
        unsafe { abi::timestamp() }
    }

    impl SystemTime {
        pub fn now() -> Self {
            Self(timestamp())
        }

        pub fn duration_since(&self, earlier: SystemTime) -> Result<Duration, Duration> {
            let diff = self
                .0
                .checked_sub(earlier.0)
                .ok_or_else(|| Duration::from_millis((earlier.0 - self.0) as u64))?;
            Ok(Duration::from_millis(diff as u64))
        }

        pub fn elapsed(&self) -> Duration {
            let diff = SystemTime::now().0 - self.0;
            Duration::from_millis(diff as u64)
        }
    }

    impl Add<Duration> for SystemTime {
        type Output = SystemTime;

        /// # Panics
        ///
        /// This function may panic if the resulting point in time cannot be represented by the underlying data structure
        fn add(self, dur: Duration) -> SystemTime {
            SystemTime(self.0 + dur.as_millis() as i64)
        }
    }

    impl AddAssign<Duration> for SystemTime {
        fn add_assign(&mut self, other: Duration) {
            *self = *self + other;
        }
    }

    impl Sub<Duration> for SystemTime {
        type Output = SystemTime;

        fn sub(self, dur: Duration) -> SystemTime {
            SystemTime(self.0 - dur.as_millis() as i64)
        }
    }

    impl SubAssign<Duration> for SystemTime {
        fn sub_assign(&mut self, other: Duration) {
            *self = *self - other;
        }
    }
}
